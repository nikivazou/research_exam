	\newcommand\qset{\ensuremath{\mathbb{Q}}}
\newcommand\NV[1]{\columnbreak}


\section{Decidable Type Systems}

In 1991 Freeman and Pfennning, at \cite{FreemanPfenning91} introduced
a decidable refinement type system for a subset of ML.
%
In their system, the programmer could refine dependent
types for data types; 
the list type of values $\alpha$ can be refined to 
describe \texttt{nil} lists, or singleton list, i.e., lists
with exactly one value.
%
These definitions are used for two reasons;
Firstly, to produce the principal type of 
data constructors as an intersection type;
for example \texttt{cons} applied to a value and an empty
list returns a singleton list; but if it is applied
to an element and a singleton list it returns an unrefined list.
More importantly, these definitions are used to 
construct a finite lattice of refinements of each ML type; 
obviously a singleton list is less than the unrefined list.
%
The datatype lattice is a representation of the subtype
relationship that is used in the 
refinement type inference algorithm. 
Since each lattice is finite, the refinement type
inference algorithm is decidable.

Later, at \cite{pfenningxi98}, 
they extended their language to support
linear arithmetic constraints; thus they could
encode a list with length some integer $n$ and 
reason about safety of list indexing.
In this system, subtyping reduces to predicate implication
and they used a variant of Fourier's method \cite{OmegaTestCACM} 
for constraint solving.
%
Finally, they created DML(C)\cite{XiPfenning99}, 
an extension of ML with dependent types, that supports 
array bound check elimination,
redundant pattern matching clause removal, 
tag check elimination and untagged representation of datatypes.
The type checking is decidable, as they define a finite and decidable
constrain domain $C$ and subtyping reduces to constraint satisfaction in the 
domain C.
%

In DML(C) programs can often be annotated with
very little internal change and the resulting
constraint simplification problems can be solved efficiently
in practice. 
%
Its disadvantage is that annotation burden is high for the programmer,  
as programmers can often expect that 10-20 percent of
their code will be typing annotations.
%
In order to encourage programmers to use dependent specifications in their programs,
Ou et all, in \cite{Ou2004}, proposed a language design and type system that allows programmers to add
dependent specifications to program fragments bit by bit. 
More specifically, certain program components are marked dependent, 
in which case the type checker verifies
statically that the programmer has properly maintained dependent typing annotations.
Other portions of the program are marked simple and in these sections, programmers
are free to write code as they would in any ordinary simply-typed programming language. When control passes between dependent and simple fragments, data flowing
from simply-typed code into dependently-typed code is checked dynamically to ensure that the dependent invariants hold.

Other improvements for DML(C), are Liquid Types \cite{LiquidPLDI08}, 
where the annotation burden greatly decreases through type inference.
We will discuss Liquid Types in the rest of the section.
% Another extension is described by Mandelbaum et all in \cite{MandelbaumWalker03},
% where the domain of predicates is extended to describe the state 
%and the effects of the programs verified.

%Semantic Subtyping
Many systems, such as DML(C) and Liquid Types use \textit{syntactic subtyping} for constraint 
generations and then use SMT Solvers, such as CVC3\cite{CVC3}, Yices \cite{Yices}, and Z3 \cite{z3}
 for constraint solving.
The opposed technique is \textit{semantic subtyping} where subtyping is totally 
decided by first order implication checking. 
Semantic subtyping is 


%{\color{green}
%add other decidable systems:
%\begin{itemize}
%\item \cite{dminor, SwamyCFSBY11}
%\item \cite{SuterKK11}
%\item \cite{UnnoTK13, VytiniotisJCR13} 
%\end{itemize}
%
%AND SITE Z3 \cite{z3}
%}

\subsection{Liquid Types}\label{sec:liquid}

In this section we will present a dependent type system which is decidable.
As we stated in the introduction, if the refinement language can contain arbitrary 
program expressions, then type checking is undecidable.
%
In Liquid Types\cite{LiquidPLDI08},  Rondon et all restricted the refinement logic according to a predetermined 
finite set of qualifiers,  which gives not only decidable type checking, but also automatic
type inference.



The system takes as input a program and 
a finite set of \textit{logical qualifiers}
which are simple boolean predicates 
that encode the properties we care to verify. 
The system then infers
liquid types, which are dependent types where the refinement predicates are conjunctions of the logical qualifiers.
In the system, type checking and inference are decidable for
three reasons. 
%
First, they use a conservative but decidable
notion of subtyping, where they reduce the subtyping of arbitrary
dependent types to a set of implication checks over base types,
each of which is deemed to hold if and only if an embedding of
the implication into a decidable logic yields a valid formula in
the logic. 
%
Second, an expression has a valid liquid type derivation
only if it has a valid unrefined type derivation, and the dependent 
type of every subexpression is a refinement of its vanilla type. 
%
Third, in any valid type derivation, the types of certain expressions
must be liquid. Thus, inference becomes decidable, as the space of
possible types is bounded. 


\subsection{Logical Qualifiers and Liquid Types.}

A logical qualifier is a
boolean-valued expression (i.e., predicate) over the program variables, 
the special value variable @v@ which is distinct from the
program variables, and the special placeholder variable $\star$ that
can be instantiated with program variables. 
We can assume, that $\mathcal{Q}$ is the set of logical qualifiers
$\{0 \leq v, \star \leq v, v < \star,  v = \star + 1\}$. 
%
We say that
a qualifier q matches the qualifier $q'$
if replacing some subset of
the free variables in q with $\star$ yields $q'$.
For example, the qualifier
$x \leq v$ matches the qualifier $\star \leq v$. 
We write $\mathcal{Q}^\star$
for the set of all
qualifiers not containing $\star$ that match some qualifier in \qset. 
For example, when \qset is as defined as above, 
and $x$, $y$ and $n$ are program variables.
$\qset^\star$
includes the qualifiers
$\{0 \leq v, x \leq v, y \leq v, v = n + 1, v <n\}$. 
A liquid type over \qset is a dependent type where the refinement predicates are
conjunctions of qualifiers from $\qset ^ \star$.

\subsection{Overview}
\subsubsection{Type Inference}

As an example consider our pred example
$$\centering
\begin{tabular}{c}
\begin{code}
pred n = n - 1
\end{code}
\end{tabular}
$$

The liquid type for @pred@ can be inferred in three steps:

(Step 1) By Hindley-Milner algorithm, 
we can infer that @pred@ has the type @Int -> Int@.
Using this type, we create a template for the liquid type of @pred@,

$$\centering
\begin{tabular}{c}
\begin{code}
pred :: n:{v:Int | k_n} -> {v:Int | k_p}
\end{code}
\end{tabular}
$$

where @k_n@ and @k_p@
are liquid type variables representing the unknown refinements for the 
argument n and the body of @pred@, respectively.


(Step 2)If moreover we assume:
$$\centering
\begin{tabular}{c}
\begin{code}
(-) :: x:Int -> y:Int -> {v:Int | v = x - y}
\end{code}
\end{tabular}
$$

The the result of @pred@ has a type
$$\centering
\begin{tabular}{c}
\begin{code}
{v:Int | v = x - y}[x/n][y/1] = {v:Int | v = n - 1} 
\end{code}
\end{tabular}
$$

But this should be subtype of the template type for the result.
So, we get the subtyping constraint
$$\centering
\begin{tabular}{c}
\begin{code}
n - 1 :: {v:Int | v = n - 1} <: {v:Int | k_p}
\end{code}
\end{tabular}
$$

which reduces to the implication constraint 

$$
v = n - 1 \Rightarrow k\_p
$$

(Step 3)Since the program is ``open'', i.e., there are no calls to @pred@,
we assign @k_p@ true, meaning that any integer arguments can be
passed, and use a theorem prover to find the strongest conjunction
of qualifiers in \qset
that satisfies the subtyping constraints. 
The algorithm
infers that $v = n-1$ is the strongest solution for @k_p@.
By substituting the solution for @k_p@ into
the template for @pred@, our algorithm infers
$$\centering
\begin{tabular}{c}
\begin{code}
pred :: n:Int -> {v:Int | v = n-1}
\end{code}
\end{tabular}
$$


\subsubsection{Type Checking}
As one may notice the inferred type signature of @pred@ does not constrain the type of the argument.
This happens because the code for pred produces no such constraint.
We could manually specify a type for @pred@

$$\centering
\begin{tabular}{c}
\begin{code}
pred :: n:{v:Int | v > 0} -> {v:Int | n - 1}
\end{code}
\end{tabular}
$$

Then then first step of the inference will be skipped and the 
body of the function will be type-checked against the given signature.

So, in the second step, as before, we will create an implication
$$n-1 \Rightarrow n - 1 $$. That can trivially be verified in the third step.

We have use the above type signature and we call @pred@ with some integer vale, say @2@
then in the call site the constraint $v = 2 \Rightarrow v >0$ will be generated, 
that can easily be verified.
%
On the other hand, if we call it with zero, we will get the constraint
$v = 0 \Rightarrow v >0$, that does not hold, 
so our program will be unsafe.

\subsection{Applications of Liquid Types}

Liquid Types, as introduced in \cite{LiquidPLDI08} used OCaml as target language
and were used to verify properties such as array bound checking.
In \cite{LiquidPLDI09} they were extended with recursive and polymorphic refinements
to enable static verification of complex data structures. For example they proved
that a list is sorted or that a tree is a Binary Search Tree.
%
Liquid Types can be used to verify properties even in imperative languages.
In \cite{Rondon10}, Rondon et. all. present a refinement type system for
C based on Liquid Types to verify memory safety properties, 
like the absence of array bounds violations
and null-dereferences.
In \cite{Kawaguchi12},
Kawaguchi et. all. present Liquid Effects, a type-and-effect system based on refinement types
which allows for fine-grained, low-level, shared memory multithreading while statically guaranteeing that a program is deterministic. 

\subsection{Formal Language}
Once again, we would like to extend $\lambda_c$ such as to support liquid type checking.

As we said earlier, the refinements in the language 
can not contain arbitrary expressions, but they are limited
to conjuctions of the logical qualifiers, which form a finite set.

They use a subtyping is the one defined in \ref{subsec:formal} 
but in this setting,  
the subtyping relation is decidable
because their refinement language is restricted
and can be checked with a SMT solver.

\begin{figure}[t!]
\centering
$$
\begin{array}{rrcl}
\emphbf{Predicates} \quad
  & p ::=
  & 	\text{true}
  \spmid q
  \spmid p \land p \ , \ q \in \mathbb{Q^\star}
  \\[0.05in] 
\end{array}
$$
\caption{\textbf{Syntax of Expressions, Types and Schemas}}
\label{fig:syntax}
\end{figure}


\begin{figure}[ht!]
\medskip \judgementHead{Type Checking}{$\hastype{\Gamma}{e}{\tau}$}

$$\begin{array}{cc}

\inference
  {  \hastype{\Gamma}{e}{\tau_2} && \isSubType{\Gamma}{\tau_2}{\tau_1} 
  && \isWellFormed{\Gamma}{\tau_1}
  }
  {\hastype{\Gamma}{e}{\tau_1}}
  [\tsub]
\end{array}$$

\caption{\textbf{Static Semantics: Well-formedness, Subtyping and Type Checking}}
\label{fig:rules}
\end{figure}