	\newcommand\qset{\ensuremath{\mathbb{Q}}}
\newcommand\NV[1]{\columnbreak}


\section{Decidable Type Systems}\label{sec:liquid}
%%Simplify!!!
In 1991 Freeman and Pfennning, at \cite{FreemanPfenning91} introduced
a decidable refinement type system for a subset of ML.
%
In their system, the programmer defines refinement
types for the vanilla data types; 
for example, the vanilla 
list data type can be refined to 
describe \texttt{nil} lists, or \texttt{singleton} lists, i.e., lists
with exactly one element.
%
These definitions are used to 
construct a finite datatype lattice of each ML type;
a singleton list or a nill list is
also an unrefined list, thus both refined lists are 
less than the unrefined one in the lattice.
%
The datatype lattice is a representation of the subtype
relationship that is used in the 
refinement type inference algorithm. 
Since each lattice is finite, the 
subtyping relation is decidable.

Later, at \cite{pfenningxi98}, 
they extended their language to support
linear arithmetic constraints; thus they could
encode a list with length some integer $n$ and 
reason about safety of list indexing.
In this system, subtyping reduces to predicate implication
and they used a variant of Fourier's method \cite{OmegaTestCACM} 
for constraint solving.
%
Finally, they created DML(C)\cite{XiPfenning99}, 
an extension of ML with refinement types, that supports 
array bound check elimination,
redundant pattern matching clause removal, 
tag check elimination and untagged representation of datatypes.
%
Refinements in DML(C) are restricted to a finite and decidable
constrain domain $C$, 
which renders constraint solving, and thus subtyping decidable.
%

DML(C)  is a practical programming language, in the sense that 
programs can often be annotated with
very little internal change and the resulting
constraint simplification problems can be solved efficiently
in practice. 
%
Its disadvantage is that annotation burden is high for the programmer,  
as programmers can often expect that 10-20 percent of
their code will be typing annotations.
%
In order to encourage programmers to use refinement specifications in their programs,
Ou et all, in \cite{Ou2004}, proposed a language design and type system that allows programmers to add
dependent specifications to program fragments bit by bit. 
More specifically, certain program components are marked dependent, 
in which case the type checker verifies
statically that the programmer has properly maintained refinement typing annotations.
Other portions of the program are marked simple and in these sections, programmers
are free to write code as they would in any ordinary simply-typed programming language. When control passes between dependent and simple fragments, data flowing
from simply-typed code into dependently-typed code is checked dynamically to ensure that the dependent invariants hold.
Liquid Types \cite{LiquidPLDI08}, 
proposed type inference, as a means of decreasing the annotation burden.
We will present Liquid Types in the rest of the section.

%Semantic Subtyping
%\mypara{SMT solvers}
Many systems discussed so far, including DML(C) and Liquid Types, 
use \textit{syntactic subtyping} for constraint 
generation and SMT solvers for constraint solving.
\textit{Satisfiability Modulo Theories}(SMT) solvers solve implications 
for (fragments of) first-order logic plus various standard theories such as
equality, real and integer (linear) arithmetic, bit vectors, and (extensional) arrays. 
Some of the leading systems include  CVC3\cite{CVC3}, Yices \cite{Yices}, and Z3 \cite{z3}.

% EXTENSIONS
Until then, the idea of syntactic subtyping for constraint generation
and an SMT solver for constraint solving has been extended in various ways:
%
Mandelbaum et all in \cite{MandelbaumWalker03},
extended the domain of predicates to describe the state 
and the effects of the programs verified.
%
Suter et all, in \cite{SuterKK11} increase the power of reasoning 
to support user defined recursive functions.
% automatic inference of ghost variables
Finally,  Unno et all, in \cite{UnnoTK13},
created a relative complete system for higher-order functional programs.
 
Apart from syntactic subtyping, SMT solvers can be used in other 
refinement decidable systems:
Dminor, \cite{dminor} uses \textit{semantic subtyping} where subtyping is totally 
decided by first order implication checking while 
HALO \cite{VytiniotisJCR13} uses \textit{denotational semantics}
to prove specification checking.




%{\color{green}
%add other decidable systems:
%\begin{itemize}
%\item \cite{SwamyCFSBY11}
%\item 
%\item \cite{} 
%\end{itemize}
%
%AND SITE Z3 \cite{z3}
%}

\subsection{Liquid Types}\label{subsec:liquid}

In Liquid Types\cite{LiquidPLDI08}, 
Rondon et all restrict the refinement language according to a 
finite set of qualifiers, and achieve not only decidable type checking, but also automatic
type inference.

The system takes as input a program and 
a finite set of \textit{logical qualifiers}
which are simple boolean predicates 
that encode the properties to be verified. 
The system then infers
\textit{liquid types}, which are dependent types where the refinement predicates are conjunctions of the logical qualifiers.
In the system, type checking and inference are decidable for
three reasons. 
%
First, they use a conservative but decidable
notion of subtyping, where 
subtyping reduces to implication checks in a decidable logic.
Each implication holds if and only if it yields a valid formula in
the logic. 
%
Second, an expression has a valid liquid type derivation
only if it has a valid unrefined type derivation, and the refinement 
type of every subexpression is a refinement of its vanilla type. 
%
Third, in any valid type derivation, the types of certain expressions
must be liquid. Thus, inference becomes decidable, as the space of
possible types is bounded. 


\mypara{Logical Qualifiers and Liquid Types.}
A logical qualifier is a
boolean-valued expression (i.e., predicate) over the program variables, 
the special value variable @v@ which is distinct from the
program variables, and the special placeholder variable $\star$ that
can be instantiated with program variables. 
Let $\mathcal{Q}$ be the set of logical qualifiers
$\{0 \leq v, \star \leq v, v < \star,  v = \star + 1\}$. 
%
We say that
a qualifier q matches the qualifier $q'$
if replacing some subset of
the free variables in q with $\star$ yields $q'$.
For example, the qualifier
$x \leq v$ matches the qualifier $\star \leq v$. 
We write $\mathcal{Q}^\star$
for the set of all
qualifiers not containing $\star$ that match some qualifier in \qset. 
For example, when \qset\ is as defined as above, 
and $x$, $y$ and $n$ are program variables.
$\qset^\star$
includes the qualifiers
$\{0 \leq v, x \leq v, y \leq v, v = n + 1, v <n\}$. 
A liquid type over \qset\ is a refinement type where the refinement predicates are
conjunctions of qualifiers from $\qset ^ \star$.

%\subsection{Overview}
\mypara{Type Inference}
Type inference is performed in three steps:
(1) The vanilla type of each expression is refined with liquid variables
which represent the unknown refinements.
(2) Syntactic subtyping is used to create implication constraints 
between the unknown variables and the concrete refinements.
(3) A theorem prover is used to find the strongest conjunction
of qualifiers in \qset\
that satisfies the subtyping constraints.   

As an example consider our pred example
$$\centering
\begin{tabular}{c}
\begin{code}
pred n = n - 1
\end{code}
\end{tabular}
$$

The liquid type for @pred@ can be inferred in three steps:

(Step 1) By Hindley-Milner algorithm, 
we can infer that @pred@ has the type @Int -> Int@.
Using this type, we create a template for the liquid type of @pred@,

$$\centering
\begin{tabular}{c}
\begin{code}
pred :: n:{v:Int | k_n} -> {v:Int | k_p}
\end{code}
\end{tabular}
$$

where @k_n@ and @k_p@
are liquid type variables representing the unknown refinements for the 
argument n and the body of @pred@, respectively.


(Step 2)If moreover we assume:
$$\centering
\begin{tabular}{c}
\begin{code}
(-) :: x:Int -> y:Int -> {v:Int | v = x - y}
\end{code}
\end{tabular}
$$

The the result of @pred@ has a type
$$\centering
\begin{tabular}{c}
\begin{code}
{v:Int | v = x - y}[x/n][y/1] = {v:Int | v = n - 1} 
\end{code}
\end{tabular}
$$

But this should be subtype of the template type for the result.
So, we get the subtyping constraint
$$\centering
\begin{tabular}{c}
\begin{code}
n - 1 :: {v:Int | v = n - 1} <: {v:Int | k_p}
\end{code}
\end{tabular}
$$

which reduces to the implication constraint 

$$
v = n - 1 \Rightarrow k\_p
$$

(Step 3)Since the program is ``open'', i.e., there are no calls to @pred@,
we assign @k_p@ true, meaning that any integer arguments can be
passed, and use a theorem prover to find the strongest conjunction
of qualifiers in \qset\
that satisfies the subtyping constraints. 
The algorithm
infers that $v = n-1$ is the strongest solution for @k_p@.
By substituting the solution for @k_p@ into
the template for @pred@, our algorithm infers
$$\centering
\begin{tabular}{c}
\begin{code}
pred :: n:Int -> {v:Int | v = n-1}
\end{code}
\end{tabular}
$$


\subsubsection{Type Checking}
As one may notice the inferred type signature of @pred@ does not constrain the type of the argument.
This happens because the code for pred produces no such constraint.
We could manually specify a type for @pred@

$$\centering
\begin{tabular}{c}
\begin{code}
pred :: n:{v:Int | v > 0} -> {v:Int | n - 1}
\end{code}
\end{tabular}
$$

Then then first step of the inference will be skipped and the 
body of the function will be type-checked against the given signature.

So, in the second step, as before, we will create an implication
$$n-1 \Rightarrow n - 1 $$. That can trivially be verified in the third step.

We have use the above type signature and we call @pred@ with some integer vale, say @2@
then in the call site the constraint $v = 2 \Rightarrow v >0$ will be generated, 
that can easily be verified.
%
On the other hand, if we call it with zero, we will get the constraint
$v = 0 \Rightarrow v >0$, that does not hold, 
so our program will be unsafe.

\subsection{Applications of Liquid Types}

Liquid Types, as introduced in \cite{LiquidPLDI08} used OCaml as target language
and were used to verify properties such as array bound checking.
In \cite{LiquidPLDI09} they were extended with recursive and polymorphic refinements
to enable static verification of complex data structures. For example they proved
that a list is sorted or that a tree is a Binary Search Tree.
%
Liquid Types can be used to verify properties even in imperative languages.
In \cite{Rondon10}, Rondon et. all. present a refinement type system for
C based on Liquid Types to verify memory safety properties, 
like the absence of array bounds violations
and null-dereferences.
In \cite{Kawaguchi12},
Kawaguchi et. all. present Liquid Effects, a type-and-effect system based on refinement types
which allows for fine-grained, low-level, shared memory multithreading while statically guaranteeing that a program is deterministic. 

\subsection{Formal Language}
Once again, we would like to extend $\lambda_c$ such as to support liquid type checking.

As we said earlier, the refinements in the language 
can not contain arbitrary expressions, but they are limited
to conjuctions of the logical qualifiers, which form a finite set.

They use a subtyping is the one defined in \ref{subsec:formal} 
but in this setting,  
the subtyping relation is decidable
because their refinement language is restricted
and can be checked with a SMT solver.

\begin{figure}[t!]
\centering
$$
\begin{array}{rrcl}
\emphbf{Predicates} \quad
  & p ::=
  & 	\text{true}
  \spmid q
  \spmid p \land p \ , \ q \in \mathbb{Q^\star}
  \\[0.05in] 
\end{array}
$$
\caption{\textbf{Syntax of Expressions, Types and Schemas}}
\label{fig:syntax}
\end{figure}


\begin{figure}[ht!]
\medskip \judgementHead{Type Checking}{$\hastype{\Gamma}{e}{\tau}$}

$$\begin{array}{cc}

\inference
  {  \hastype{\Gamma}{e}{\tau_2} && \isSubType{\Gamma}{\tau_2}{\tau_1} 
  && \isWellFormed{\Gamma}{\tau_1}
  }
  {\hastype{\Gamma}{e}{\tau_1}}
  [\tsub]
\end{array}$$

\caption{\textbf{Static Semantics: Well-formedness, Subtyping and Type Checking}}
\label{fig:rules}
\end{figure}