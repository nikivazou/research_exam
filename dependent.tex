\section{Introduction}

%\subsection{Overview}

Functional programming languages, like ML and Haskell,
come with strong static types system, which detects a lot 
of errors at compile-time and enhances code documentation.


The utility of these type systems stems from their ability to predict, 
at compile-time, invariants about the run-time values computed by the program. 
%
Unfortunately, classical type systems only
capture relatively coarse invariants. For example, the system can
express the fact that a variable @i@ is of the type @Int@, 
meaning that it is always an integer, 
but not that it is always an integer with a
certain property, say different than zero. 
%
Thus, the type system is unable to statically ensure the safety of critical operations, 
such as a division by i. 
%
Several authors have proposed the
use of refinement types \cite{FreemanPfenning91} as a mechanism for enhancing the
expressiveness of type systems. 

\textit{Refinement types} refine a vanilla type with a predicate.
For example, one can give @i@ the following type:
$$\centering\begin{tabular}{c}
\begin{code}
i :: {v:Int | v != 0}
\end{code}
\end{tabular}$$

that describes all values @v@ of type @Int@,
moreover, the refinement predicate constraints 
the value @v@ to be different than @0@.


One can use this refinement type to define a safe division operator:

$$\centering\begin{tabular}{c}
\begin{code}
safeDiv :: Int -> {v:Int | v != 0} -> Int
\end{code}
\end{tabular}$$

This type expresses the fact that the division operator takes two
@Int@ arguments and returns an @Int@.
Moreover restricts the second argument to be different that
zero, to eliminate division by zero operations. 

When the function @safeDiv@ is called, 
the type system should check that the real arguments do not
violate @safeDiv@'s specification.
%
For instance, 
@safeDiv 8 9@ is safe, since @9@ is always different that zero.
But, @safeDiv 8 0@ should create a type error.
Apart from concrete values, @safeDiv@ can be applied to arbitrary program expressions:
@safeDiv n m@ is safe only if 
@m@ is an integer different than zero.

\mypara{Refinement Function Types}
Refinement function types, allow the specification of the 
result to depend on the arguments.
%
Parameters are used to bind function arguments
and can appear in the refinement of the result.
%
%Dependent types, allow the refinement of the result of a function
%to depend on function's arguments.
As an example, we define a @pred@ function, 
that takes an argument @n@ and returns the predecessor of @n@,
and give it a very descriptive type:

$$\centering\begin{tabular}{c}\begin{code}
pred :: n : Int -> {v:Int | v = n-1}
pred n = n-1
\end{code}\end{tabular}$$

This type expresses that for each integer argument @n@, 
the result is an @Int@ exactly equal to @n-1@.
When @pred@ is applied to a concrete value, 
the parameter @n@ is substituted with this value.
For example @pred 2 :: {v:Int | v = n-1}[2/n] = {v:Int | v = 1}@.
Thus, for each concrete argument, the result should be the predecessor 
of this argument.

\mypara{Verification}
The \textit{verification} is a procedure that takes an input 
a program, i.e.,  definitions for functions and values,
and some specifications, i.e., refinementtype signatures for functions and values,
and decides whether the specifications hold for the program.
%
Informally, it checks that 
each expression satisfies its type, 
for example, the @pred@ definition actually returns the 
predecessor of its argument
or that 
at each function application the arguments satisfy
the function's preconditions, 
as in the @safeDiv@ example.
%
If the specifications hold, the program is \textit{Safe}, 
otherwise it is \textit{Unsafe}. 

Higher-order programming languages, such as ML or Haskell, 
treat functions as first order objects.
Thus, one can use functions in refinements and 
create higher-order predicates. 
For instance, the following type

$$\centering\begin{tabular}{c}\begin{code}
f:(a->b) -> {v:Bool|terminates f}
\end{code}\end{tabular}$$

describes that an arbitrary functional argument
should satisfy a predicate @terminates@.
%
Reasoning in a higher-order logic is undecidable, 
thus if arbitrary program values appear in the refinements,
the verification procedure is undecidable.
%
As we will see, 
if the refinement language is , i.e., is less expressive,
verification can be decidable.

The rest of this paper is organized as follows:
In section \ref{subsec:formal}, we present a core calculus
that constitutes the base for many refinement type systems.
In section \ref{sec:undec},
we describe reasoning in undesidable refinement type systems.
In section \ref{sec:liquid}, 
we present less expressive type systems
that are decidable.
In section \ref{sec:abstract} 
we present, how abstraction over refinements
enhances expressiveness of decidable type systems. 
Finally, we conclude.

\section{Preliminaries}\label{subsec:formal}

To be able to formally describe and compare the type systems, 
we will define a a core calculus $\lambda_c$, its syntax and type system:

\mypara{Syntax}
The syntax of expressions and types is summarized in Figure \ref{fig:syntax}.
$\lambda_D$ expressions include variables, constants, $\lambda$-abstractions
and function applications. 
Basic types can be integer or boolean.
$\lambda_D$ types can be dependent types and function types.
The predicate $p$ is
not yet defined. As we noted earlier, if $p$ contains arbitrary program 
expressions, the type system is undecidable.
In dependent function types we use a variable to bind the argument, 
as it can be used in the type of the result.

Finally, we define a typing environment $\Gamma$, that maps variables to their type.

\mypara{Static Typing}

There are three types of judgments:
\begin{itemize}
\item{\emphbf{Wellformedness judgments} (\isWellFormed{\Gamma}{\tau})} 
state that a type $\tau$ is well-formed under environment
$\Gamma$, that is, the refinements in $\tau$ are boolean 
expressions in the environment $\Gamma$.

\item{\emphbf{Subtyping judgments} (\isSubType{\Gamma}{\tau_1}{\tau_2})} 
state that the type $\tau_1$ is a subtype of the type
$\tau_2$ under environment $\Gamma$, that is, when the free variables
of $\tau_1$ and $\tau_2$
are bound to values described by $\Gamma$, the set of values described
by $\tau_1$ is contained in the set of values described by $\tau_2$. 


\item{\emphbf{Typing judgments} (\hastype{\Gamma}{e}{\tau})} state that
the expression $e$ has the type $\tau$ under environment $\Gamma$,
that is, when the free variables in $e$ are bound to values described by 
$\Gamma$, the expression $e$ will evaluate to a value described by $\tau$.
\end{itemize}

\mypara{Wellformedness Rules}
The wellformedness rules check that the 
refinements are indeed $\tbbool$-valued expressions in the 
appropriate environment.
The rule \wtBase checks that the  
refinement $\reft$ is boolean.
The rule \wtFun recursively applies the wellformdness rule to
the argument type of the function, and to the result type, 
after it adds the argument binder with the correct type to 
the environment.

\mypara{Subtyping Rules}
The subtyping rules stipulate when the set of values described 
by type $\tau_1$ is subsumed by the values described by $\tau_2$.
%
The rule \tsubBase serves two purposes:
Firstly,
it checks that the basic type is the same in the two types, 
as in vanilla type systems
Moreover, it checks that under the environment $\Gamma$, 
the left hand side refinement implies the right hand side.
To do so, we use a \texttt{Valid} predicate which varies between the systems that we will describe.
%
The rule \tsubFun relates two function types according to the contravariant rule.

\mypara{Type Checking Rules}
The type checking rules check that an expression in of the correct type.
%The rule \tsub states that if an expression is of type $\tau$, 
%then it can be types as any supertype of $\tau$.
The rule \tconst checks the types of the constant expressions, according 
to their definitions.
The rule \tvariable checks the types of the variables, according 
to the environment $\Gamma$.
%The rule \tfun checks the types of the variables, according 
%to the environment $\Gamma$.
The rule \tfunction checks both that the argument type is well-formed 
and that the type of the function-body
is correct in the environment, extended with the argument of the function.
Finally, the rule \tapp checks that $e_1$ is has a function type
and that its argument has the type of the argument $e_2$.
Also, in the result type, the argument $x$ is replaced with the actual argument $e_2$.

You may notice that the subtyping relation 
is not used in this basic rules,
but as we stated, the core calculus will be extended to formalize the
type systems that we will describe.

\begin{figure}[t!]
\centering
$$
\begin{array}{rrcl}
\emphbf{Expressions} \quad 
  & e 
  & ::= 
  &      x 
  \spmid c 
  \spmid \efunt{x}{\tau}{e} 
  \spmid \eapp{e}{e} 
%  \spmid \etabs{\alpha}{e} 
%  \spmid \etapp{e}{\tau} 
  \\[0.05in] 

\emphbf{Predicates} \quad 
  & p
  & ::= 
  & \dots
  \\[0.05in] 

\emphbf{Basic Types} \quad 
  & b 
  & ::= 
  &      \tbint
  \spmid \tbbool
%  \spmid \alpha
  \\[0.05in]

\emphbf{Dependent Types} \quad 
  & \tau 
  & ::= 
  &      \tref{b}{p} 
  \spmid \tfun{x}{\tau}{\tau}
  \\[0.05in]

\emphbf{Typing Environment} \quad 
  & \Gamma 
  & ::= 
  &      \emptyset 
  \spmid x:\tau, \Gamma

\end{array}
$$
\caption{\textbf{Syntax of Expressions, Types and Schemas}}
\label{fig:syntax}
\end{figure}


\begin{figure}[ht!]
\judgementHead{Well-Formedness}{\isWellFormed{\Gamma}{\tau}}


$$\inference
    {\hastype{\Gamma, p:b}{\reft}{\tbbool}}
    {\isWellFormed{\Gamma}{\tref{b}{p}}}
    [\wtBase]
\qquad
\inference
    {
    \isWellFormed{\Gamma}{\tau_x} &&
	\isWellFormed{\Gamma, x:\tau_x}{\tau}
    }
    {\isWellFormed{\Gamma}{\tfun{x}{\tau_x}{\tau}}}
    [\wtFun]
$$


\medskip \judgementHead{Subtyping}{\isSubType{\Gamma}{\tau}{\tau}}

$$
\inference
   {(\Gamma, v:b \vdash \texttt{Valid}(p_1 \Rightarrow p_2))}
   {\isSubType{\Gamma}{\tref{b}{p_1}}{\tref{b}{p_2}}}
   [\tsubBase]
$$

$$
\inference
   {\isSubType{\Gamma}{\tau_{21}}{\tau_{11}} &
	\isSubType{\Gamma, x_2:{\tau_{21}}}{\SUBST{\tau_{12}}{x_1}{x_2}}{\tau_{22}}	
   }
   {\isSubType{\Gamma}
	  {\tfun{x_1}{\tau_{11}}{\tau_{12}}}
	  {\tfun{x_2}{\tau_{21}}{\tau_{22}}}
}[\tsubFun]
$$


\medskip \judgementHead{Type Checking}{$\hastype{\Gamma}{e}{\tau}$}

\begin{comment}
$$\begin{array}{cc}

\inference
  {  \hastype{\Gamma}{e}{\tau_2} && \isSubType{\Gamma}{\tau_2}{\tau_1} 
  && \isWellFormed{\Gamma}{\tau_1}
  }
  {\hastype{\Gamma}{e}{\tau_1}}
  [\tsub]
\end{array}$$
\end{comment}
$$\begin{array}{cc}

\inference
  {}
  {\hastype{\Gamma}{c}{\tc{c}}}
  [\tconst]
&
\inference
  {x:\tau \in \Gamma}
  {\hastype{\Gamma}{x}{\tau}} 
  [\tvariable]

\end{array}$$

$$\begin{array}{cc}

\inference
  {\hastype{\Gamma, x:\tau_x}{e}{\tau} &&     
  \isWellFormed{\Gamma}{\tau_x}
  }
  {\hastype{\Gamma}{\efunt{x}{\tau_x}{e}}{\tfun{x}{\tau_x}{\tau}}}
  [\tfunction]
&
\inference
  {\hastype{\Gamma}{e_1}{\tfun{x}{\tau_x}{\tau}} &&
   \hastype{\Gamma}{e_2}{\tau_x}
  }
  {\hastype{\Gamma}{\eapp{e_1}{e_2}}{\tau[e_2/x]}} 
  [\tapp]

\end{array}$$

\caption{\textbf{Static Semantics: Well-formedness, Subtyping and Type Checking}}
\label{fig:rules}
\end{figure}